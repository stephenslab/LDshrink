include: "parameter_generation/Snakefile"
import pandas as pd

import os
gardner_dir="../../../../../../../../group/xhe-lab/1KG/"
rcc_dir="../../../../../../project/xinhe/eQTL/1kg/"
if os.path.exists(gardner_dir):
    configpath="workflow_params_gardner.json"
else:
    if os.path.exists(rcc_dir):
        configpath="workflow_params_rcc.json"
    else:
        configpath="workflow_params.json"

configfile:
    configpath    
#Directory that will serve as base directory for this project (good idea to use scratch storage)
KG_dir=config["KG_DIRECTORY"]

#Directory that holds "raw" 1000 genomes vcf files (I think this already exists in the `compbio` folder in the `RSS` folder)
VCF_DIR=config["VCF_DIR"]

#Directory that holds the haplotype and genotype `.gds` which are population specific (i.e EUR), and have had an allele frequency cutoff applied (i.e 0.05)
GDS_DIR=config["GDS_DIR"]

#Directory that holds the 1000 genomes genetic map files (you can get these off github, google 1000 genomes genetic maps)
KG_MAPDIR=config["KG_MAPDIR"]


# File that has the LDetect LD breakpoints
#URL for that file is here #LD_break_file_url="https://bitbucket.org/nygcresearch/ldetect-data/raw/ac125e47bf7ff3e90be31f278a7b6a61daaba0dc/EUR/fourier_ls-all.bed"


subworkflow gwas_subset_ldsc:
    workdir: "ldsc_pipeline"

           
LD_break_file=config["LDETECT_BREAK_FILE"]
LD_df=pd.read_csv(LD_break_file,delim_whitespace=True)
LD_df['region_id']=LD_df.index+1


with open("scz_LD_regions.txt") as f:
    ALL_REGIONS=f.read().splitlines()
#ALL_REGIONS=[x for x in list(LD_df['region_id']) if x != 1187]

def filter_chrom(df,chrom):
    return list(df[df['chr']=="chr"+str(chrom)]['region_id'])


#To generate different files, change the value of the variable `simulation_file`
#(the fact that the variable is  called `simulation_file` doesn't have any significance)
rule all:
    input:
        "sim_scz_RSSp_res.txt.gz",
        KG_dir+"RSSp_sim_gwas_genome/scz_sim_all_quh.RDS"

        
wildcard_constraints:
    chrom="\d+"

## Rules for transforming VCFs to gds files
        
rule subset_gds:
    ''' This rule creates the gds file that will be used by most of the subsequent rules, It should be somewhere on RCC or gardner, and shouldn't have to be re-run'''
    input:
        mapf=KG_dir+"1000-genomes-genetic-maps/interpolated_hapmap.RDS",
        temp_gds=expand(KG_dir+"gds/ALL.chr{chr}.gds",chr=range(1,23)),
        geno_gdsf=expand(KG_dir+"gds/ALL.chr{chr}_geno.gds",chr=range(1,23)),
        breakf=LD_break_file
    output:
        gdsf=GDS_DIR+"ALL_seq_hapmap.gds",
        geno_gdsf=GDS_DIR+"ALL_seq_hapmap_geno.gds"
    threads: 1
    script:
        "scripts/gds_subset.R"        


        



### Rules for simulating GWAS data

rule sim_pheno_w_Beta_RSSp:
    ''' This rule starts with a gds file (gdsf)
    and a dataframe with (at least) these  columns :
    `SNP`: the SNP rsid (character)
    `beta`: the true effect size (double)
    `fgeneid`: The trait name (character)
    And generates an HDF5 file with (among other things)
    a (scaleed) matrix of trait values. Noise is added to the data to 
    match the desired PVE specified in the parameter PVE
    '''
    input:
        gdsf=rules.subset_gds.output.geno_gdsf,
        beta_dff="betadf.RDS"
    params:
        pve=PVE
    output:
        h5f=KG_dir+"RSSp_sim_gwas_pheno/simulate_y.h5"
    script:
        "scripts/simulate_y.R"


rule gen_snpinfo:
    ''' This rule starts with a gds file (gdsf)
    and generates a dataframe with all of the SNPs in the data.
    '''
    input:
        gdsf=rules.subset_gds.output.geno_gdsf
    output:
        snpif="snpinfo.RDS"
    script:
        "scripts/gen_snpinfo.R"

rule sim_Beta_RSSp:
    ''' This rule starts with a gds file (gdsf) 
    and a dataframe (of the kind generated by gen_snpinfo)
    and generates a dataframe of betas with (at least) these  columns:
    `SNP`: the SNP rsid (character)
    `beta`: the true effect size (double)
    `fgeneid`: The trait name (character)
    Be sure that PVE is specified at the desired level
    '''
    input:
        gdsf=rules.subset_gds.output.geno_gdsf,
        snp_infof="snpinfo.RDS"
    params:
        pve=PVE
    output:
        beta_dff="betadf.RDS"
    script:
        "scripts/simulate_beta.R"        
        

rule sim_pheno_w_Beta_resid_RSSp:
    ''' This rule works very similarly to sim_pheno_w_Beta_RSSp, but takes 
    an extra input, a nxg (where n is the sample size and g is the number 
    of traits to be simulated) matrix stored in a RDS file that represents
    the residuals.  Use this rule if you don't want to use the built in method
    for computing PVE
    '''
    input:
        gdsf=rules.subset_gds.output.geno_gdsf,
        beta_dff="betadf.RDS",
        resid_f="residmat.RDS"
    params:
        pve=PVE
    output:
        h5f=KG_dir+"RSSp_sim_gwas_pheno/simulate_y_residuals.h5"
    script:
        "scripts/simulate_y_residuals.R"        
    


rule sim_pheno_RSSp:
    ''' This rule works very similarly to sim_pheno_w_Beta_RSSp, but doesn't require beta,
    and instead generates it on the fly.  This is the rule used in LD score regression/RSSp 
    comparisons
        '''
    input:
        gdsf=GDS_DIR+"{trait}_seq_hapmap_geno.gds"
    params:
        fgeneid=expand("{fgeneid}",fgeneid=FGENEID),
        pve=PVE,
        bias=BIAS,
        nreps=NREPS
    output:
        h5f=KG_dir+"RSSp_sim_gwas_pheno/{trait}_trait.h5"
    threads: 1
    script:
        "scripts/gen_ty_block_RSSp.R"

rule map_betahat_se:
    ''' This rule takes a SeqArray gds file and an HDF5 file 
    (of the kind generated by any of the sim_pheno rules) and 
    returns a dataframe that has a layout simiar to  the `betadf`
    input to sim_pheno_w_beta_RSSP.  In this rule the univariate betahat and se_hat
    replace beta)
        '''
    input:
        gdsf=rules.subset_gds.output.geno_gdsf,
        ymatf=rules.sim_pheno_w_Beta_RSSp.output.h5f
    output:
        sumstatf=KG_dir+"sim_gwas_summary_stats/simulation.txt.gz"
    params:
        chunksize=10000
    script:
        "scripts/map_betahat_se.R"        




# rule merge_LD_region:
#     input:
#         evdf=lambda wildcards: expand(KG_dir+"EVD_H5/1KG_hapmap_{LDchunk}.h5",LDchunk=filter_chrom(LD_df,wildcards.chrom))
#     output:
#         evd_chunkf=KG_dir+"EVD_CHROM_H5/1KG_hapmap_{chrom}.h5"
#     script:
#         "scripts/concat_h5.R"
        
rule ldsc_chunk:
    input:
        gdsf=rules.subset_gds.output.gdsf
    params:
        chrom="{chrom}",
        outdir=KG_dir+"eur_w_ld_chr"
    output:
        outf=KG_dir+"eur_w_ld_chr/{chrom}.l2.ldscore.gz",
        soutf=KG_dir+"eur_w_ld_chr/{chrom}.l2.M_5_50"
    script:
        "scripts/ldsc_chunk.R"



rule chunk_RSSp_chrom:
    input:
        rdsf=KG_dir+"RSSp_sim_gwas_{chrom}/sim_all.RDS",
        evd_chunkf=KG_dir+"EVD_CHROM_H5/1KG_hapmap_{chrom}.h5"
    params:
        fgeneid=expand("{fgeneid}",fgeneid=FGENEID)
    output:
        logf=KG_dir+"RSSp_est_{gwas}_{chrom}/sim_results.RDS"
    script:
        "scripts/fast_RSSP_chunk.R"


rule gen_quh_chunk:
    input:
        evdf=KG_dir+"EVD_H5/1KG_hapmap_{LDchunk}.h5",
        uhf=KG_dir+"RSSp_genome_gwas_uh_chunk/{trait}_{LDchunk}_sim.h5"
    params:
        LDchunk="{LDchunk}"
    output:
        quhf=KG_dir+"RSSp_genome_gwas_quh_chunk/{trait}_{LDchunk}_sim.h5"
    script:
        "scripts/gen_quh_chunk.R"
                  
   
        
rule map_uh_RSSp:
    input:
        gdsf=rules.sim_pheno_RSSp.input.gdsf,
        ymatf=rules.sim_pheno_RSSp.output.h5f
    params:
        LDchunk="{LDchunk}"
    output:
        LDchunkf=KG_dir+"RSSp_genome_gwas_uh_chunk/{trait}_{LDchunk}_sim.h5"
    threads: 1
    script:
        "scripts/map_uh_LDchunk_RSSp.R"        

rule merge_quh_region:
    input:
        evdf=expand(KG_dir+"RSSp_genome_gwas_quh_chunk/{{trait}}_{LDchunk}_sim.h5",LDchunk=ALL_REGIONS),
        phenof=rules.sim_pheno_RSSp.output.h5f
    params:
        LDchunk=expand("{LDchunk}",LDchunk=ALL_REGIONS)
    output:
        rdsf=KG_dir+"RSSp_sim_gwas_genome/{trait}_sim_all_quh.RDS"
    script:
        "scripts/concat_quh.R"

rule RSSp_sim_mat_est:
    input:
        rdsf=rules.merge_quh_region.output.rdsf
    output:
        dff="sim_{trait}_RSSp_res.txt.gz"
    script:
        "scripts/mat_RSSp_sim_mat_est.R"
        

rule merge_uh_region:
    input:
        evdf=expand(KG_dir+"RSSp_genome_gwas_uh_chunk/{LDchunk}_sim.h5",LDchunk=ALL_REGIONS),
        phenof=KG_dir+"RSSp_sim_gwas_pheno/trait.h5"
    params:
        LDchunk=expand("{LDchunk}",LDchunk=ALL_REGIONS)
    output:
        rdsf=KG_dir+"RSSp_sim_gwas_genome/sim_all_uh.RDS"
    script:
        "scripts/concat_uh.R"                



rule ldsc_chrom_est:
    input:
        ldsc_f="ldsc/ldsc.py",
        sumstatf=KG_dir+"ldsc_sim_{gwas}_{chrom}/sim_{fgeneid}.sumstats.gz",
        chroml2=KG_dir+"eur_w_ld_chr/{chrom}.l2.ldscore.gz"
    params:
        out_pref=KG_dir+"ldsc_est_{gwas}_{chrom}/sim_{fgeneid}",
        ld_dir=KG_dir+"eur_w_ld_chr/"
    output:
        logf=KG_dir+"ldsc_est_{gwas}_{chrom}/sim_{fgeneid}.log"
    shell:
        "python2 ldsc/ldsc.py --h2 {input.sumstatf} --ref-ld-chr {params.ld_dir} --w-ld-chr {params.ld_dir} --out {params.out_pref}"
                # "module load python/2.7.13; source activate ~/python2_project/bin/activate; ldsc/ldsc.py --h2 {input.sumstatf} --ref-ld-chr {params.ld_dir} --w-ld-chr {params.ld_dir} --out {params.out_pref}"
        
rule ldsc_parse_est:
    input:
        logf=expand(KG_dir+"ldsc_est_{{gwas}}_{{chrom}}/sim_{fgeneid}.log",fgeneid=FGENEID),
        tparamf=expand(KG_dir+"ldsc_sim_{{gwas}}_{{chrom}}/sim_{fgeneid}_tparam.tsv",fgeneid=FGENEID)
    output:
        logf=KG_dir+"ldsc_est_{gwas}_{chrom}/sim_results.tsv"
    params:
        fgeneid=expand("{fgeneid}",fgeneid=FGENEID)
    script:
        "scripts/parse_ldsc.R"


rule get_ldsc:
    output:
        "ldsc/ldsc.py"
    shell:
        "git clone https://github.com/bulik/ldsc.git"


rule sim_chrom_RSSp:
    input:
        gdsf=rules.subset_gds.output.geno_gdsf
    params:
        chrom="{chrom}",
        fgeneid=expand("{fgeneid}",fgeneid=FGENEID),
        pve=PVE,
        bias=BIAS,
        nreps=NREPS
    output:
        rdsf=KG_dir+"RSSp_sim_gwas_{chrom}/sim_all.RDS"        
    script:
        "scripts/sim_chrom_RSSp.R"


        

rule parse_ldsc_chrom:
    input:
        gdsf=rules.subset_gds.output.geno_gdsf,
        rdsf=rules.sim_chrom_RSSp.output.rdsf
    params:
        chrom="{chrom}",
        fgeneid=expand("{fgeneid}",fgeneid=FGENEID),
        pve=PVE,
        bias=BIAS,
        nreps=NREPS
    output:
        outf=expand(KG_dir+"ldsc_sim_gwas_{{chrom}}/sim_{fgeneid}.sumstats.gz",fgeneid=FGENEID),
        soutf=expand(KG_dir+"ldsc_sim_gwas_{{chrom}}/sim_{fgeneid}_tparam.tsv",fgeneid=FGENEID)
    script:
        "scripts/sim_chrom_ldsc.R"        







        
rule sim_ldsc_chrom_direct:
    input:
        evd_chunkf=KG_dir+"EVD_CHROM_H5/1KG_hapmap_{chrom}.h5",
        gdsf=rules.subset_gds.output.geno_gdsf
    params:
        chrom="{chrom}",
        pve=PVE,
        bias=BIAS,
        nreps=NREPS
    output:
        outf=expand(KG_dir+"ldsc_sim_direct_{{chrom}}/sim_{fgeneid}.sumstats.gz",fgeneid=FGENEID),
        soutf=expand(KG_dir+"ldsc_sim_direct_{{chrom}}/sim_{fgeneid}_tparam.tsv",fgeneid=FGENEID),
        rdsf=KG_dir+"RSSp_sim_direct_{chrom}/sim_all.RDS"
    script:
        "scripts/sim_chrom_ldsc_direct.R"
        
        

rule impute_2_snpgds:
    input:
        hapf=KG_dir+"impute/ALL.chr{chr}.impute.hap",
        legf=KG_dir+"impute/ALL.chr{chr}.impute.legend",
        mapf=KG_dir+"1000-genomes-genetic-maps/interpolated_hapmap/chr{chr}.interpolated_genetic_map.gz",
        filt_f="EUR.samples"
    params:
        chrom="{chr}"
    output:
        gdsf=KG_dir+"gds/ALL.chr{chr}.gds",
        geno_gdsf=KG_dir+"gds/ALL.chr{chr}_geno.gds"
    script:
        "scripts/impute_2_seqgds.R"

    


rule vcf_2_impute:
    input:
        vcff=VCF_DIR+"ALL.chr{chr}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz",
        filt_f="EUR.samples"
    params:
        out_pref=KG_dir+"impute/ALL.chr{chr}"
    output:
        hapf=KG_dir+"impute/ALL.chr{chr}.impute.hap",
        legf=KG_dir+"impute/ALL.chr{chr}.impute.legend"
    shell:
        "vcftools --gzvcf {input.vcff} --IMPUTE --out {params.out_pref} --keep {input.filt_f} --min-alleles 2 --max-alleles 2 --maf 0.05"
             
    
rule vcf_2_gds_all:
    input:
        vcff=expand(VCF_DIR+"ALL.chr{chr}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz",chr=range(1,23))
    output:
        temp_gds=temp("ALL.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes_seq_hapmap.gds"),
    threads: 10
    script:
        "scripts/vcf2seq_gds.R"        

rule map_file_RDS:
    input:
        mapf=expand(KG_MAPDIR+"interpolated_from_hapmap/chr{chr}.interpolated_genetic_map.gz",chr=range(1,23))
    output:
        mapf=KG_dir+"1000-genomes-genetic-maps/interpolated_hapmap.RDS"
    script:
        "scripts/map2RDS.R"

rule ld_chunk_1kg:
    input:
        gdsf=rules.subset_gds.output.gdsf
    output:
        evdf=KG_dir+"EVD_H5/1KG_hapmap_{LDchunk}.h5"
    params:
        region_id="{LDchunk}"
    script:
        "scripts/evd_1kg.R"

        
rule extract_cell_array:
    input:
        filename="genotype.mat"
    output:
        filename="genotype.h5"
    params:
        groupname="snp_info"
    run:
        import h5py
        import numpy as np
        with h5py.File(input.filename,'r') as f:
            data = [ f[element[0]][:] for element in f[params.groupname]]

        with h5py.File(output.filename,'w') as wf:
            for i in range(len(data)):
                wf.create_dataset(params.groupname+'/'+str(i),data[i].shape,data=data[i])



# rule sim_genome_RSSp:
#     input:
#         gdsf=rules.subset_gds.output.geno_gdsf
#     params:
#         fgeneid=expand("{fgeneid}",fgeneid=FGENEID),
#         LDchunk=expand("{LDchunk}",LDchunk=ALL_REGIONS),
#         pve=PVE,
#         bias=BIAS,
#         nreps=NREPS
#     output:
#         rdsf=KG_dir+"RSSp_sim_gwas_genome/sim_all.RDS",
#         LDchunkf=expand(KG_dir+"RSSp_genome_gwas_uh_chunk/{LDchunk}_sim.h5",LDchunk=ALL_REGIONS)
#     threads: 2
#     script:
#         "gen_sim_genome_RSSp.R"                



# rule RSSp_chrom:
#     input:
#         gdsf=rules.subset_gds.output.geno_gdsf,
#         sumstatf=expand(KG_dir+"ldsc_sim_{{gwas}}_{{chrom}}/sim_{fgeneid}.sumstats.gz",fgeneid=FGENEID),
#         tstatf=expand(KG_dir+"ldsc_sim_{{gwas}}_{{chrom}}/sim_{fgeneid}.sumstats.gz",fgeneid=FGENEID),
#         evd_chunkf=KG_dir+"EVD_CHROM_H5/1KG_hapmap_{chrom}.h5"
#     params:
#         fgeneid=expand("{fgeneid}",fgeneid=FGENEID)
#     output:
#         logf=KG_dir+"RSSp_est_{gwas}_{chrom}/sim_results.tsv"
#     script:
#         "RSSP_chunk.R"                

# rule t_ld_chunks:
#     input:
#         gdsf=KG_dir+"gds/ALL.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes_seq_hapmap.gds"
#     output:
#         temp_chunkf="{LDchunk}.txt"
#     script:
#         "list_ld_regions.R"

# rule dl_panel_info:
#     input:
#         FTP.remote("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel",
#                    keep_local=True)
#     params:
#         pop="EUR"
#     output:
#         outf="EUR.samples"
#     shell:
#         "cat {input} | grep -w '{params.pop}' | awk '{{print $1}}' > {output.outf}"


# rule vcf_filt_hap:
#     input:
#         vcff=KG_dir+"vcf/ALL.chr{chr}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz",
#         panelf="EUR.samples"
        
#     output:
#         KG_dir+"_filt/ALL.chr{chr}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz"

                
# rule snpgds_2_seqgds:
#     input:
#         temp_gds="snp_gds/ALL.chr{chr}.snp_gds"
#     output:
#         temp_seq="snp_gds/ALL.chr{chr}.seq_gds"
#     script:
#         "snp_2_seqgds.R"

        
# rule dl_vcf:
#     input:
#         FTP.remote("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr{chrom}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz",keep_local=True)
#     output:
#         KG_dir+"vcf/ALL.chr{chrom}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz"

#     run:
#         shell("mv {input} {output}")

# rule dl_vcf_tbi:
#     input:
#         FTP.remote("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr{chrom}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz.tbi",keep_local=True)
#     output:
#         "vcfs/ALL.chr{chrom}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz.tbi"


#     run:
#         shell("mv {input} {output}")
